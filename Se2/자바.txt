                          
명령 프롬프트
 
	- .   : 현재폴더
	- ..  : 상위폴더
	- dir : 경로에 속한 파일과 하위 디렉터리 목록을 보여줌
	- md  : 폴더 생성  
	- cd  : 폴더 이동
	- cd\ : 최상위 폴더로 이동



java 기초상식

	- JDK : 자바 개발 도구
	- JRE : 자바로 만든 프로그램을 실행시켜주는 환경 (JDK에 포함)
	- java SE : 핵심 기본 기술 (Application)
	            -> java EE : 분산, 네트워크, jsp, android
	            -> java ME : 하드웨어, 모바일
	            -> java FX : 플래쉬
	- path : 원하는 위치 등록 -> 위치 상관없이 사용가능



변수설정(시스템변수에 없을시 새로만들것)
	
	시스템변수 -> Path ->  JDK -> bin파일 경로 추가
	시스템변수 -> JAVA_HOME -> JDK 경로 추가



주석방법

	1.   //  한줄 주석처리
	
	2.   /*
	         여러줄 주석처리
	     */




특수문자(제어문자) : 일반적인 문자에 특수한 역할을 부여한것
 	사용방법         ->         \특정문자
	
	\n : 줄바꿈 기능
	\t : 탭 기능



escap문자 : 특수한 역할을 부여한 특수문자를 일반적인 문자로 만드는것
 	사용방법         ->         \\특정문자



0. 기초

    - 보조기억장치 : 저장만 가능
    - LOAD : 보조기억장치에서 주기억장치로 저장된 정보를 전송하는 것
    - 주기억장치 : 
    - RAM : 휘발성  
   

1.variable( 변수 )

    -> 변하는 값을 임시로 저장
    -> 변수가 사용하는 장치(공간) RAM
    -> 변수를 사용하기 위해선 선언을 해야함 [종류,크기 : 데이터 타입(Data Type)]
    -> 문법  : 데이터타입 변수명;
    -> 초기화(변수를 처음 선언한 후 첫번째를 저장하는 행위)를 해야함
			(error:variable i might not have been initialized System.out.println(i); <<초기화가 되지않았을때 에러메시지)
    -> 선언된 블럭 안에서만 유효



2. 기본 Data Type

     -정수형     ->byte(1byte)    
				->short(2byte)
				->int(4byte) : default
				->long(8byte)   
 
     -실수형		->float(4byte)
				->double(8byte) : default

     -문자형		->char(2byte)

     -논리형		->boolean : 참 혹 거짓 으로 정해져있음



#. equal( = )

    -> a = b
    -> b를 a에 저장



#. CODE

    아스키코드
	-> 96개의 대소 영문자, 숫자, 특수 문자와 32개의 제어 문자만 입력 가능(총 128개)

    유니코드
	->아스키코드 + 8BIT 를 한 코드

			

#. 문자사용
  
   1. '문자' -> 한글자, 크기변환 불가능
   2. "문자" -> 한글자이상 , 크기변환 가능



#. ant

	- build.xml : 파일명



3. Operator

		ㄱ. 산술 연산자  :  *, /, %, +, -, ++(증가연산자), --(감소연산자)

         ㄴ. 비교 연산자(관계연산자) : >, <, >=, <=, ==, !=
	
		ㄷ. 논리 연산자 : &&(and) -> 단락회로, ||(or) -> 단락회로, !(not) -> "toggle"

		ㄹ. 비트 연산자(2진수) : &(and), |(or), ^(xor), <<(left shift), >>(right shift), >>>(right shift), ~(보수)

		ㅁ. 대입 연산자(치환 연산자) : =, -=, =+, *=, /=, %=    -> 캐스트 연산자 기능이 내장되어 있음


3. Operator

		ㅂ. 캐스팅 연산자(강제로 데이터 형태를 변형)
	
			문법 = (데이터형태)변수
				1) 묵시적(암시적)캐스팅
				2) 명시적캐스팅
			
		ㅅ. 삼항 연산자
		
			문법 = (조건)? a : b
				1) a : 참일때 실행
				2) b : 거짓일때 실행
	
		ㅇ. 배타적 OR연산자( ^ ) 
		        1) 두개의 값이 서로 다를때 참
				2) 암호화, 복호화에 사용



1. System.in.read : 키보드의 키 하나를 읽어온다

   System.in.skip : 한칸을 건더뛴다.




2. 제어문 (Control Statement)
	조건	
		- if       
			ㄱ. 
			    if(조건식) {
				 참인경우;       -> 참인 경우만 가능
			    }


			ㄴ. 
			    if(조건식) {     
				 참인경우;       -> 한가지 조건만 가능
			    } else {
				 거짓인 경우;
			    }


			ㄷ. 
			    if(조건식1) {
				 조건식1 참인경우;   -> 다중 조건 가능
			    } else if (조건2) {
				 조건식2 참인경우;
			    } else if (조건3) {
				 조건식3 참인경우;
			    }
			      else {
				 마지막 조건이 거짓인 경우;
			    }

			ㄹ. Nested if문
			
			    if(조건식1){
				조건식1 참인경우;
					if(조건식2){
						조건식2 참인경우;
					}
					if(조건식3){
						조건식3 참인경우;
					}
			    }


		- switch   :
			switch(값 또는 수식) {
				case 값:
					실행문;
					break;
				case 값:
					실행문;
					break;
				case 값:
					실행문;
					break;
				default :                -> 생략가능
					실행문;
					break;
	

                 => 값에 정수만 와야 하며, int보다 작은 정수만 가능하다.

                 => 범위를 줄 수 없다.

1. 반복문 ( Loop statement )
	- 반복 횟수
	- 무한 반복
	
	  초기화
	  조건식
	  카운터*


		ㄱ. while
			- while(조건식) {
				실행문;        // 조건이 참이 유지되는 동안만 반복 실행
	 		  }
		
		ㄴ. do while
			- do {
				실행문;
			  }while(조건식);  // 최소한 1번은 실행되며, 실행 후 조건비교
					
		ㄷ. for
			- for(초기값 ; 조건식 ; 카운터) {
				실행문;
			   }
					
			- 초기화
			  for( ;조건식;카운터){
				실행문;
			  }
			
			- 초기화
			  for( ; ;카운터){
				조건식;
			  }
	
			- 초기화
			  for( ; ; ){
				조건식;
				카운터;
			  }


*. 무한반복

		- while(ture){
			...
		}
	
		- for( ; ; ){
			...
		}


*. 반복문 강제 종료

		1. break      : 완전 종료
		2. continue   : 일시 종료


*. nested loop
	for( ; ; ) {
		for ( ; ; ) {
		실행문;	
		}
	실행문;
	}


1. 클래스 (class)
		- 사전적 의미 : 묶음 { 인스턴스 변수, 메서드 }
		- 설계도(추상적)
			-> 인스턴스(instance) , 객체(object)
			
		- 가장 기본적인 단위
	
		- 인스턴스
			: 클래스명 참조변수명 = new 클래스명();
			: 참조변수명.변수명 = value;
			
		- 객체 데이터 타입으로 사용 가능
		- 클래스안에서 선언된 변수는 인스턴스 변수라고한다
		- 한 파일에 클래스가 많을 땐 메인클래스(메인메소드를 가지고있는)명으로 저장

	- 객체(object)
		- 하나의 프로그램을 이루는 각 각의 구성요소이며 독립적인 기능

		ㄱ. 상속성 (재사용성, 업그레이드)
		ㄴ. 다형성
		ㄷ. 캡슐화 (편리성, 보안성)

	- 객체 데이터 타입(user define datatype)
		- 해당 클래스명으로 데이터타입을 만들어야함.
		- 참조변수( 인스턴스의 주소를 저장하는 변수)	
			: 클래스명 참조변수;

	- 메소드(method) - > 동작 , 처리방법
		ㄱ. 만드는 방법
			- 리턴타입 메서드명(){
				처리방법(동작)기술;
			   }

		ㄴ. 사용 방법(호출)
			메서드명();
	
			1)호출방식
				- 인자가 없는 방식 : 메소드명()
				- 인자가 있는 방식 : 메소드명(데이터타입 변수)
				- 리턴값이 있는 방식

		ㄷ. return  
			- 값을 반환할때 사용(1개만 가능)
			- 메서드의 강제 종료

		
		ㅁ. 메소드의 overloading(중복정의)
			- 똑같은 이름의 메소드의 여러개 만들수있는 기능
			- 매개변수의 갯수, 형식, 위치가 달라야함

* 자바 지식
	- 모듈 : 중복되는 것들을 별도로 분리시키는 방법
    - 인터럽터
	- 스택  
	- 실인자 : 메소드호출할때 가져가는 변수값
	- 매개변수 : 메소드에서 값을 받는 변수
	- java.lang.System.out.println()
        	-> out : 인스턴스 주소 , 참조변수
			-> println() : 프린트메소드
			-> System : System이라는 클래스
			-> java , lang : 폴더, package



1. 생성자(constructor)
		ㄱ. 호출 시점
			: 인스턴스 생성 시 자동으로 호출되는 메소드
			: 객체 생성 연산자 new에 의해 호출됨 
				- 일회용 
				- 초기화 전용
	
		ㄴ. 메서드명은 클래스명과 동일 ->  클래스명 참조변수 = new 클래스명();
		ㄷ. 반환형식이 존재하지 않는다.
		ㄹ. 모든 클래스는 반드시 기본생성자(인자 X)가 존재
		ㅁ. 임의의 생성자를 생성 시 기본 생성자가 제공되지않음
		ㅂ. 생성자에서 자동으로 초기화를 해준다.


2. Garvage Collection
	- Garvage : 더 이상 사용하지 못하는 인스턴스 공간

	- System.gc()

	- finalize() : callback method, garvage 수거되기 직전 System이 호출
		     : 마무리가 되지않은 인스턴스를 확인 하려고 하는 메소드


3. this(예약어)
		ㄱ. 참조변수
		ㄴ. 현재 실행 중인 인스턴스의 주소가 저장되어있음
		ㄷ. read only( 읽기 전용 )
		ㄹ. 메소드의 매개변수로 항상 존재
		ㅁ. this.변수, this.메서드
		ㅂ. this() : 자기 자신의 또 다른 생성자를 호출
		ㅅ. 인스턴스변수명과 매개변수명이 같을때 반드시 인스턴스변수명 앞에 this를 붙여 구별함


4. 배열
	ㄱ. 같은 이름으로 정의된 연속적인 공간
	ㄴ. 객체로 취급

@ 자바지식
	* main method : 최대한 간단하게
	* 생성자가 없는 클래스는 없다, 없으면 인스턴스 생성이 안된다.
	* API : 개발 도구
	* 포팅 : 서로 다른 환경에서 사용할수있게 뜯어 고침
	* JVM : 자바 가상 머신 , 운영체재와 상관없이 사용 할 수 있는 메모리 공간
	* javac.exe : 자바소스를 JVM(자바 가산머신)으로 옮겨가서 컴파일을 시켜주는 실행파일
		   		: 바이트 코드
	* java.exe : JVM에 있는 실행파일을 컴퓨터로 가져가 실행 할수있도록 하는 실행파일
	* 이클립스 단축키 : http://blog.naver.com/yysvip/220086472105


4. 배열(array)

	ㄱ. 같은 이름으로 정의된 연속적인 공간
	ㄴ. 객체로 취급
	ㄷ. 1차원배열(선형배열) : 떨어져 있는 변수들을 한줄로 붙여 놓은것, 하나의 인덱스가 필요 , 값을 다룸
	ㄹ. 2차원배열(다차원배열) : 1차원배열을 하나로 붙여 놓은것, 행과 열 즉 두개의 인덱스가 필요 , 주소를 다룸
	ㅁ. 3차원배열(다차원배열) : 면, 행, 열 ( 세개의 인덱스 ) , 주소를 다룸
	ㅂ. 배열은 반복문에 사용 가능

	


5. 검색 알고리즘 
	순차 검색 	
	이분 검색(정렬)

6. 정렬(sort) : 오름차순,내림차순
		
		* swap(교환) 알고리즘
		
			int a = 10;
			int b = 5;
			int c;		// 임시 저장 장소
		
			c = a;
			a = b;
			b = c;


	ㄱ. 버블 정렬 : 서로 이웃하는 것끼리 비교해서 교환해 나가는 방식

		8	7	9	2	3	6
		-----------------------------------------
		7	8	9	2	3	6
		
		7	8	9	2	3	6
		
		7	8	2	9	3	6

		7	8	2	3	9	6
		
		7	8	2	3	6	9
		-----------------------------------------
		7	8	2	3	6	9

		7	2	8	3	6	9

		7	2	3	8	6	9

		7	2	3	6	8	9
		-----------------------------------------
		2	7	3	6	8	9
		
		2	3	7	6	8	9

		2	3	6	7	8	9
		-----------------------------------------
		2	3	6	7	8	9
	
		2	3	6	7	8	9
		-----------------------------------------
		2	3	6	7	8	9
		
		

	ㄴ. 선택 정렬 : 기준을 선택해서 두 값을 교환해 나가는 방식
	
		8	7	9	2	3	6
		-----------------------------------------
		7	8	9 	2	3	6

		7	8	9 	2	3	6

		2	8	9 	7	3	6
	
		2	8	9 	7	3	6

		2	8	9 	7	3	6
		-----------------------------------------
		2	8	9 	7	3	6

		2	7	9 	8	3	6

		2	3	9 	8	7	6

		2	3	9 	8	7	6
		-----------------------------------------
		2	3	8 	9	7	6
		
		2	3	7 	9	8	6

		2	3	6 	9	8	7
		-----------------------------------------
		2	3	6 	8	9	7

		2	3	6 	7	9	8
		-----------------------------------------
		2	3	6 	7	8	9

	ㄷ. 삽입 정렬
	

* 메모리
		- stack : 후입선출(LIFO)
			-> 변수
			-> 메서드의 복귀 주소
			-> 참조변수
			-> 임시저장


     	- heap
			-> 값을 안전하고 오래보관
			-> 인스턴스

		- queue : 선입선출
			-> 주로 시스템이 사용

* 배열
	- int k[i][k]	 -> i : 주소를 저장
	 	     		 -> k : 값을 저장
	      	     	 -> k.length : 행의 길이
		      		 -> k[i].length : 열의 길이

	- 배열은 같은 데이터 형식만 묶을 수 있다.


1. 불규칙 배열(동적 바인딩) : 각 행 마다 열의 크기가 달라 테이블의 모양이 불규칙하다
	
		char[] name1 = {'T', 'O', 'M'};
		char[] name2 = {'J', 'O', 'H', 'N', 'S', 'O', 'N'};
		char[] name3 = {'J', 'A', 'N', 'E'};
	
		char[][] names = new char[3][7]
			->가장 긴 숫자 기준
		------------------------------------------------	
		char[][] names = new char[3][]  //열은 차후 결정
		...
		names[0] = new char[3];
		names[0] = new char[7];
		names[0] = new char[4];


2. String

		- 기본적으로 1차원배열이 포함
		- java.lang
		- 문자열 : 객체
			String name = new String();
			name.메서드()
			"문자열".메서드()
		- 동일한 인스턴스를 중복해서 생성하지않는다.
		  (단, new를 통해서 생성하지 않았을 경우에만 해당)

2. String
		- 기본적으로 1차원배열이 포함
		
		- java.lang
		
		- 문자열 : 객체
			ㄱ. String name = new String();
			    name.메서드()
		 	
			ㄴ. "문자열".메서드()
		
		- 동일한 인스턴스를 중복해서 생성하지않는다.
		  (단, new를 통해서 생성하지 않았을 경우에만 해당)
		
		- 수정 불가(Garbage가 생김)
			String str = "abc";
			str = "efg";
	
	 

	* StringBuffer(수정 가능)
		- 수정가능
		- 반드시 new가 있어야함 : StringBugger 변수 = new StringBugger();
		- append() : 인스턴스에 저장되어있는 문자열에 문자열을 덧붙임.
		- reverse() : 인스턴스에 저장되어있는 문자열을 거꾸로 출력함.
		- equals(), == : 주소비교


	* Command Line Argment(명령행 인자)
		- main메소드에 전달
		- 명령어 다음에 입력되는 옵션 

	* java.text.DecimalFormat df = new java.text.DecimalFormat("#.###");

	* java.util.Scanner scan = new java.util.Scanner();


3. Access Modifier(접근 제한자) - 1 : 변수 메서드 클래스

		ㄱ. default(anonymous): 접근허용, 생략
			- 부분 허용(같은 패키지만 접근 가능)
			
		ㄴ. public : 접근허용
			- 완전 허용(모든 패키지 접근 가능)
	
		ㄷ. private : 접근불가
			- 완전 불가(같은 클래스만 가능), 우수한 보안성
			- 값을 저장하거나 수정할수있는 돌파구를 만들고 사용해야함
			
			- setter 메서드 : private로 사용하였을때 값을 저장할수있게 해주는 메소드
	
			- getter 메서드 : private로 사용하였을때 값을 조회할수있게 해주는 메소드
	
			 (get, set) 권장
	
			  void set변수(데이터유형 변수){
				this.변수 = 변수;
			  }
			  double get변수(){			
				return 변수;
			  }
	
		ㄹ. protected : 접근불가, 
			- 부분 불가(같은 패키지만 가능)

4. 메서드

	호출방식 : 인자 없는 방식
		  	  인자 있는 방식
	          return값이 있는 방식

	인자 전달 방식
	
		1) 값에 의한 전달(call by value)
			: 소량의 데이터, 간단한 데이터
			
		2) 참조에 의한 전달(call by reference) 
			: 대량의 데이터, 복잡한 데이터



5.static : 변수 메서드 클래스

			ㄱ. 인스턴스와는 별도로 생성되는 메모리
			ㄴ. 클래스에서 단 한개만 생성되는 메모리
			ㄷ. 모든 객체가 공동으로 사용하는 메모리
				(별도로 혼자서 사용)
			ㄹ. static이 붙은 변수 : 클래스 변수
			ㅁ. 메소드안에서는 선언할수 없다.
			ㅂ. static block
				static{
					static 변수들을 초기화
				}
			ㅅ. static은 프로그램이 시작하자마자 생성됨

=======================================================================
8월 29일

* 디자인 패턴(Design Pattern)
 	 - 싱글턴 패턴(Singleton Pattern) : 인스턴스를 단하나만 생성
 									: 생성자, private, static

* 중첩 클래스
		- 종류
		    : 비정적 클래스 ( 내부 클래스 )
	 	    : 정적(static) 클래스
				-> 같은 클래스가 아닌 다른클래스에선 클래스명을 명시해주고 호출해야함

* 상속
		- extends
			- 상속하는 클래스 : 부모클래스(superclass)	
			- 상속받는 클래스 : 자식클래스(subclass)
	
		- 상속 불가
			- 생성자
			- Private
			
		- 부모의 생성자 호출가능, 단 가장 먼저 호출해야 한다.
			- super() : 부모의 생성자 호출
			- super :  부모 인스턴스의 주소
			
		- 생성자의 호출순서
	
		- 상속의 종류
			ㄱ. 단일 상속 : 상속해주는 부모가 하나, 사용률 多
				        : 부모클래스는 가장 기본적인 기능만 가지고 있어야 한다.
			ㄴ. 다중 상속 : 기능의 중복이 생길수도 있음
	
	
		- 부모와 자식클래스의 참조관계
			1) 인스턴스가 결정되지 않았을경우
				Parent obj1 = new Class1();
		 	    	 ...
			        Class1 obj2 = (Class1)obj1;
			2) 여러개의 자식 인스턴스를 관리
				Child1 c1 = new Child1();
				Child2 c2 = new Child2();
				Child3 c3 = new Child3();
				Child4 c4 = new Child4();
	
				Parent[] p = { c1, c2, c3, c4}
	
	
				* 서로다른 클래스끼린 주소참조가 안된다.
				* 부모만 자식의 주소를 참조가 가능
				* 자식이 추가한 부분은 부모가 모른다


* 라이브러리( 클래스 묶음 )



* 패키지 인터페이스 - > 예외처리 -> IO -> 스레드 -> AWT+Swing ->Network

1. 메서드의 오버라이딩(Overriding) : 재정의
   메서드의 오버로딩(Overloading) : 중복

	- 공통점 : 다형성을 지원, 메서드에서만 가능
	- 차이점 : 오버라이딩  -> 하나를 가지고 계속 고쳐서 사용
			    	    -> 상속에서만 가능(부모클래스에서 물려받은것들을 수정하여 사용)

		       오버로딩   -> 같은 이름의 메서드를 여러개 사용
			  		    -> 환경 제약이 없다
			  		    
			  		    
			  		    
2. 추상 메서드, 추상 클래스
		
		1) 추상(abstract) 메서드
			ㄱ) 내용없이 선언만 되어있는 메서드
			ㄴ) 오버라이딩을 해야한다.(강제성)
			ㄷ) 메서드 앞에 abstract 키워드 사용
	
		2) 추상 클래스
			ㄱ) 추상메서드를 1개 이상 보유
			ㄴ) 클래스 앞에 abstract 키워드 사용	
			ㄷ) 인스턴스를 생성할수 없다.(상속을 위해서만 사용되는 클래스)
				
		3) 상속과 관련된 중요한 키워드
			- final(어디든지 사용가능)	: 수정 금지, 값을 보호 및 쉽게 식별
				final int i = 10;  // 변수 -> 상수로 변함
					      i = 20;  // 불가능
					      
			    final int MAX_AGE = 100; // 구별을 위해서 상수를 대문자로 쓰는게 관례
			    for(int i = 0 ; i < MAX_AGE ; i++)
			        ... 
			        
		    - final 메서드 : 오버라이딩 금지
		    
		    - final 클래스 : 상속 금지
		    
		    
		4) object 클래스
			- 최고 조상 클래스, 모든 클래스들은 기보적으로 object를 상속받는다.
			
			
3. 패키지 ( package ) 
		- 클래스들을 특성에 맞게 하나로 묶는 역활
		- 용도 : 
				ㄱ. 클래스 정리
				ㄴ. 클래스명 충돌 방지		
				ㄷ. 상위폴더에서 실행 (패키지.클래스명)
			
			
		* jar압축프로그램
				jar.exe (압축할때 : c - 압축  v - 압축정보  f - 이름지정)
						(압축풀떄 : x - 출때  v - 압축정보  f - 이름지정)
		
		    			-> jar cvf 압축하고싶은이름.jar 생성되있는파일명
 
 
 
* Access Modifier(접근 제한자) - 2 

		ㄱ. default(anonymous): 접근허용(같은 패키지만 접근 가능)
			
		ㄴ. public : 접근허용(모든 패키지 접근 가능)
	
		ㄷ. private : 접근불가(완전불가 - 같은 클래스만 가능)
	
		ㄹ. protected : 접근불가(같은 패키지만 가능) - 상속을 받아 자손클래스에서 접근, 사용이 가능
		
		
1. 인터페이스(interface)
		인터페이스 -> 클래스 (상속가능, 반대로 불가)
		
		1) 클래스를 설계하기 위한 설계도(클래스 보조)
		
		2) 목적
			- 클래스를 좀더 정확하고 안전하게 설계
			- 표준화를 위한 약속, 규칙
			- 의존성을 최소화
			
		3) 완전(순수) 추상 클래스	
			- 100% 추상메서드로 이루어진 클래스
			
		4) 다중 상속 가능
		
		5) class에서 interface를 구현할때 implements를 사용
		   interface 끼리 확장할 때는 extends
		   
		6) 인터페이스 안에 변수들에겐 public static final 이 붙어있다.
		
 
* collection
	변수 - 배열 - 클래스 - 컬렉션
			: 같은 데이터유형 끼리만 묶을수 있다.
			: 크기를 정해놔야 한다.
			: 삽입 삭제가 어렵다.
			
			1) hierarchy
				- collection
				     set 						list
				    -----	   		   	  	   ------
				    1. 정렬순서가 없다.   		   1. 정렬순서가 있다.
				    2. 중복되지 않는다.		   2. 중복된다.
				    3. HashSet, LinkedHashSet  3. ArrayList, Vector, LinkedList
					   TreeSet(정렬 가능)
					-----					   ------
											  -add("") : 추가
											  -get() : 저장된값 호출
											  -contains("") : 검색
											  
				- Map(두개의 데이터를 묶어서 한쌍을 한쌍씩 저장)
					HashMap, HashTable									


* Generic
		
			1. 목적
				1) 특정타입(객체 타입)을 미리 검사
					- 사전에 잘못된 데이터 타입을 미리 체크
				
			2. 문법
				1) 사용법:(Generic으로 만들어진 클래스를 사용하는 방법) 
					클래스<객체타입> 참조변수 = new 클래스<객체타입>();
 
 * 예외처리
 			1. 에러가 발생했을 때 에러에 대한 제어권을 시스템(JVM)이아니라 개발자가 처리할수 있도록 하는 방법
 			
 			2. 사용이유
 				1) 예외 발생 시 메시지 표현
 				2) 프로그램의 비 정상적인 종료
 				3) 웹의 경우 예외가 발생하면 불필요한 코드가 노출
 			
 			3. 도구
 				1) try(에러 발생하는지 감시)
 				2) catch
 				3) throw
 				4) throws
 				5) finally 
 				
 			4. 문법
 				1)
	 				try {
	 				}
	 				catch(...){
	 					예외에 대한 처리
	 				}
	 				
 				2) throw 예외 클래스의 인스턴스;
 					: 블럭 안에서만 사용가능
 					: 예외를 단 한개만 던질 수 있다.
 					: 예외처리를 다른 메소드에서 처리
					: 에러를 일부로 발생
					
				3) throws 예외 클래스
				    : 블럭바깥(메서드 바깥)에서만 사용가능
				    : 예외를 여러개 던질 수 있다.
					 					
 		    5. 예외 클래스
	 		    Throwable
	 		    1) Errors : 하드웨어와 관련된 에러
	 		    2) Exception : 소프트웨어 관련(코드 에러)
	 		    

1. 예외처리
		[1] throws
			1) 기능
				getMessage : 에러가 났을 시 에러에대한 자세한 메세지 출력
				printStackTrace : 에러가 났을 시 에러에대한 자세한 메세지 출력(getMessage보다 상위)
				toString :에러 부분을 추적해서 자세한 메세지 출력 
			
			
		[2] finally
			- 반드시 try와 같이 사용해야 한다. 	
			- 반드시 실행해야 하는 코드를 작성(실행을 보장받는다.)
			- 예외 : System.exit(0) <<강제종료
		
		
2. IO

	1) Stream 구조를 갖는다.
		- 일차원적인 데이터 흐름
		- 단방향
		- 순차적
		- 지연발생( 항상 같은 속도가 아님 )
		- 추상적(어떤 장치를 사용하던간에 사용법은 거의 동일하다.)

	2) 자바에서 구현하고 있는 stream 방식
		- Byte Stream : 사람이 보아서 알 수없지만 프로그램에서 사용할수있는 데이터로 구성됨 스트림
				- InputStream
				- OutputStream		
					- FileInputStream : 파일로부터 입력되는 스트림을 처리하는 클래스	
					- FileOutputStream : 파일로 스트림을 출력하는 클래스
				 
		- Character Stream : 사람이 이해할수 있는 문자로 구성된 스트림
				- Reader
				- Writer
					- FileReader : 파일로부터 문자 스트림을 입력받는 클래스
					- FileWriter : 파일로 문자 스트림을 출력하는 클래스
					
		- Print Stream : 
				-
				
				
	* filetest1
	* cmd 명령어 :type                                                                                                                                                       
				
	*. PrintWriter
	*. ObjectOutputStream
	
1. AWT
	1)재료
		- component
		
		- Button, Canvas(그림을 그릴수있는 화면), Checkbox, Choice(선택박스), Label(문자열만 출력, 가장 단순), 
		  List(목록출력, Choice와 동격), Scrollbar
		  
		- Container: 다시상속을해줘야하는 클래스
			-Panel(독자적 사용 불가 , 부분디자인)
				Applet
				
			-window
				Dialog(사용자와 컴퓨터 사이에 대화전달역활)
					FileDialog
					
				Frame(창크기 지정해야함, 메인에 인스턴스생성할것)
				
		- TextComponent(글자 입출력 가능) : 다시상속을해줘야하는 클래스
	2)디자인
	3)동작
				
		1. AWT
			Dialog
			
			  - 사용방법
				1) Common Dialog(System Dialog) : 이미 만들어져있는 디자인
												: File Dialog
				2) User Define Dialog : 직접 디자인
									  : Dialog 클래스 상속
									  : 반드시 하나의 생성자를 호출해야한다.									  
			  - 실행방법
			    1) Modal(동시 작업 불가)
			    2) Modaless(동시 작업 가능)
			    
			배치(Layout)
				
				1)LayoutManager
			   		-FlowLayout 
			   			순서대로 배치
			   			Panel, Applet
			   		-BorderLayout 
			   			동, 서 ,남 ,북, 가운데 배치(테두리를 기준)
			   			Window, Frame, Dialog, ...
			   		-GridLayout
			   		 	테이블 모양으로 배치(규칙적인 행과 열을 지정하여 배치)
			   		-GridBagLayout
			   		 	테이블 모양으로 배치(불규칙적 행과 열을 지정하여 배치)
			   		-CardLayout 
			   			반드시 이벤트 필요
			   			
			   			
			이벤트(EVENT)
				1) 이벤트 소스
					사건을 일으킨 컴퍼넌트
				2) 이벤트 클래스
					어떤 이벤트인지 구분
					java.util.EventObject
						java.awt.AWTEvent
							ActionEvent			: 컴퍼넌트가 활성화 시 발생되는 이벤트
							AdjustmentEvent		: 스크롤바와 같이 조정 가능한 컴퍼넌트에서 조정이 일어날때 발생되는 이벤트
							ComponentEvent		
								ContainerEvent  : 컨테이너에 컴퍼넌트가 추가/삭제되는 경우 발생되는 이벤트 
								FocusEvent		: 컴퍼넌트에 포커스가 들어왔을 때 발생하는 이벤트
								InputEvent
									KeyEvent	: 키보트 입력에 의해서 발생하는 이벤트 
									MouseEvent	: 마우스의 움직에 의해서 발생하는 이벤트
								PaintEvent		: 컴퍼넌트가 그려져야 할 떄 발생하는 이벤트
								WindowEvent     : 윈도우가 활성화 또는 닫힐때 발생하는 이벤트
								
							ItemEvent			: 리스트, 초이스와 같이 선택 항목이 존재하는 컴퍼넌트에서 
												  선택항목이 선택될때 발생되는 이벤트
							TextEvent			: 텍스트 컴퍼넌트의 내용이 변화될때 발생하는 이벤트
				3) 이벤트 핸들러(인터페이스)
					이벤트를 처리하기 위한 클래스(반드시 인터페이스를 구현해야함)
						- 리스너 인터페이스
							
							
				4) 이벤트 소스와 이벤트 핸들러 연결
					이벤트 소스.add???Listener(핸들러 주소); 			    
			
				
				5) 이벤트 코딩 방식
					ㄱ. 이벤트 소스와 이벤트 핸들러가 같은 클래스인 경우
					ㄴ. 이벤트 소스와 이벤트 핸들러가 다른 클래스인 경우
					ㄷ. 내부 핸들러가 내부 클래스인 경우 
				
				
	*. 래퍼 ( wrapper ) 클래스
	 	: 객체가 아닌 비객체(기본 데이터 타입)를 포장하여 객체처럼 사용할수 있도록 해주는 것 
	 	ex) ㄱ.	int i = 0;
	 		   	i.메서드();
	 		ㄴ.	Integer
	 		
	*. 필터 ( filter ) 클래스
		: 기존 클래스를 재포장하며 성능을 올리거나 보안하는것
		ex) new InputStreamReader(System.in)
		
	* 데이터를 입력받아 합계를 구하시오
		[getSelectedItems : 복수선택]
	
	1. 메뉴
		1) 종류
			ㄱ- 고정식메뉴(Pull Down Menu)
			ㄴ- 이동식메뉴(Pop Up Menu)
				- 마우스 오른쪽 버튼, 키보드	
	
	2. 구성
		1)메뉴바 : 메뉴를 붙일 수 있는 바
		2)메뉴 : 메뉴 바 위에만 붙일수 잇음
		3)메뉴 아이템 : 서브메뉴
		@ActionEvent 사용
		
	

	* Swing -> MVC
			-> Model(하나의 데이터) View Controller
			-> Controller는 View와 Model 사이에서 조정해 주는 역할
			-> View에서 들어온 input을 Model에 전달하고 Model에서 처리한 결과를 View에 전달시켜준다.
			-> 경량 컴퍼넌트(일부분을 구성할수있는것) - frame, applet
			-> 중량 컴퍼넌트(최상의 부모로부터 상속받은것 - 
	
					   제목    이미지 정렬
		ㄱ. new JLabel(title, icon, horizontalAlignment);
	
		ㄴ. EtchedBorder(Color.강조, Color.그림자)
		
		ㄷ. BevelBorder(BevelBorder.???) : 입체감
		
		ㄹ. 변수명.pack() : 맞춤 사이즈
		
		ㅁ. KeyAdapter : 키보드로 입력받을수 있도록 도와줌
				
		ㅂ. JScrollPane : 스크롤이 장착된 패널
		
		ㅅ. JOptionPane.??? : 여러가지옵션을 불러와서 사용할수잇다.
				- JOptionPane.showMessageDialog(null, message);
				
		ㅇ. new DefaultTableModel(title, 0) : 타이틀, 레코드 크기
		
	   
*** launch4j
    Jsmooth
    
    
*** Runnable jar file  -> 실행할수있는 jar파일
*** jar file -> 소스파일이 담긴 jar파일
    

	SI(시스템 통합)
	 - 타 시스템을 경험할 기회가 많다.
	 - 업무 이해/분석능력이 향샹 된다.
	 - 문제 대처/해결 능력이 향상된다.
	 - 프로젝트 전체의 흐름을 이해한다.
	 -----------------------------------------------
	 - 업무의 전문성이 떨어진다.
	 - 안정적인 근무환경을 보장받지 못한다.
	 - 마감일에 쫓기는 근무조건으로 자기 개발에 소홀해 진다.
	
	SM(시스템 유지보수)
	 - 업무에 있어서 전문성을 가질 수 있다.
	 - 안정적인 근무환경을 보장 받을 수 있다.
	 - 자기 스케줄이 가능하다.
	 - 시스템 장악능력을 갖는다.
	 -----------------------------------------------
	 - 시스템의 특정 파트로 업무가 국한되어 전체를 바라보는데 능력이 떨어 질수 있다.
	 - 현 추세가 아웃소싱으로 전환하는 경우가 많아 고용 안정을 보장 받지 못하는 경우가 이다.
	 
	 Solution()
	  - 개발 기간을 보장받기 때문에 안정적인 작업이 가능하다.
	  - 한 분야에 전문성을 가질 수 있다.
	  (C, Java, C# 등 특정 분야의 전문가로 양성될 수 있다.)
	  ----------------------------------------------
	  - IT의 많은 분야를 경험할 기회가 적다.
	  - 특정 모듈 개발자로 전략할 수 있다.
	  
	 FreeLancer
	  - 경력보다 능력에 비례하여 급여를 인정받을 수 있다.
	  - 계약 조건에 따라 근무 조건이 자유롭다.
	  - 본인이 원하는 분야의 일을 골라서 할 수 있다.
	  - 본인 노력에 따라 SI업체보다 더 많은 경험의 기회를 가질 수 있다.
	  ----------------------------------------------
	  - 소속감 결여와 책임감이 떨어진다.
	  - 자기 경력을 증명하기 곤란한 경유가 있다.
	  - 수시로 계약기간을 갱신하는 등 고용안정이 불안하다.
	  - 수요가 없을 때에는 백수다.
	  - 제도권 보호를 받기 힘든 경우가 있다.
	  ----------------------------------------------
	
	
	  * Thread
		: 하나의 프로그램 안에서 실행 가능한 작업 단위
		: 동시에 프로그램 실행 가능한것 (멀티 쓰레드)
		: 하나는 필요하다.
		
		[ 여러가지 메서드 ]
		
			ㄱ. run() : 자식 쓰레드 활동 공간
			             -> start() : run()을 사용하는 방법
			ㄴ. sleep() : 1/1000 기준이며, 정해진 시간만큼 쉬게하여 다른일을 처리하게 해준다.
					   : 예외처리가 필요하다.
		 
			ㄷ. getName() : 부모에 저장되어있는이름을 호출
			
			ㄹ. currentThread().getId()
			
			ㅁ. start() : 자식 스레드 실행
			
			ㅂ. synchronized : 메소드에 붙여주면된다 접근연산자뒷부분
			
			
	   [스레드 생성부터 종료까지] 
	   [스레드 클래스의 메소드  ]
	   스레드의 생성	->	start	->	Run(단 하나의 스레드만 사용할수있다.)	-> 종료
	   					   <- suspend(resume으로 다시 start로 보냄) <-
	   					   <- sleep(정해진 시간체크후 start로 보냄) <-
	   					   <- block(자동으로 쉬고 자동으로 start로 보냄) <-
	   					   <- wait(notify,notifyall start로 보냄) <-
	   					   		  (동기화 일때만 가능 (동기화 : 동시접근을 못하게 해주는것.)
	   					   		  	- 세마포어 알고리즘(융통성이 높고, 구현은 어렵다.)
	   					   		  	- 뮤텍스 알고리즘(융통성이 낮고, 구현은 쉽다.)

	   		- 종료방법
	   			ㄱ. 자연스러운 종료
	   			ㄴ. 비정상적인 종료
	   				- 불가피한 종료
	   				- 강제 종료
	   					-> stop( 될수있는 한 쓰지않는것을 권장)
	   					-> flag( 직접처리, 그나마 원만하게 종료)
 
2. 스레드의 종료 시점
	1) isAlive() = 프로그램에서 쓰레드가 살아서 움직이고 있는지 테스트하는 메소드이다
	2) join() = 쓰레드가 끝날때까지 기다려주는 메서드
	

	#프로토콜 (protocol)
	
	osi 7계층
		- 응용
		- 세션
		- 표현
		- 전송
		- 네트워크
		- 링크
		- 물리
	
	    1) TCP(전송) - 연결 지향 방식, 특정다수
	    			 - ServerSocket
	    			 - Socket
		2) UDP(사용자정의) - 비 연결 지향 방식, 불특정다수
						  - DatagramPacket
						  - DategramSocket
		패킷(packet)
			: 데이터 조각단위
			
		Ip - realIP - StaticIP(고정)
					- DynamicIp(유동)   
					- InetAddress		
		   - VirtuarIp(로컬네트워크)
		   
		Port - 네트워크에 연결되는 통로  
		Socket - 
		
		
		URL
			프로토콜://호스트:[포트번호]/[파일][#섹션]


	* UDP
		1) DatagramPacket
		
		
									데이터 알맹이, 데이터 크기
			- 생성자 : DatagramPacket(byte[] buf, int length) 
					: 데이터를 받음
			
									데이터 알맹이, 데이터 크기, 서버의 주소, 서버의 포트번호
			- 생성자: DatagramPacket(byte[] buf, int length, InetAddress address, int port)	
				   : 데이터를 보내는 용도 



		

		
						