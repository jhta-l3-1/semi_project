		**** oracle ****
						   
	데이터 베이스(Database)
	
	- 프로젝트 주제  -> 자료수집 (문서화시킬것) -> 프로토타입 -> 개발
			(svn, Maven, git)
	
	- 빅데이터_hadoop		
	
			* Database
				- 삽입
				- 삭제			=> DBMS
				- 수정 
				- 조회*
		
		
			* 관리자 
			  개발자 
			  
			* 서버 - 
			  로컬 - Access (내 컴퓨터안에서만 사용)
			  
			* 오라클 클라이언트 프로그램
				- SqlPlus
				- Sql Developer
				- Toad 
				- SqlGate
			
				
				[ C:\app\jhta\oradata : 실제 데이터가 저장된 폴더 ]
				
			* 데이터 베이스의 종류
				1. 계층형 DB - 트리
				2. 네트워크형 DB[ 계층형 DB를 보안하기 위함] - 그래프 순환
				3. 관계형 DB[★, 이차원 배열] - 테이블 
				4. 개체지향형 DB - 복잡한 데이터를 단순화하기 위함
				5. 객체관계형 DB - 
				
				★★ 관계형 DB
				
					필드 : 필드는 속성이라고하며 테이블의 열을 의미한다.
						   필드는 데이터값을 기억하는 기억단위
						  
				    레코드 : 레코드는 튜플이라고하며 테이블의 행을 의미한다.
				    	   
				    관계도 : 필드 < 레코드 < 테이블 < 데이터베이스 < 데이터뱅크
					
				    사용 :  show(명령어) user(객체) : 현재 사용자를 보여줌
	
				    	   connect, conn : 계정변경시
				    	   			    	   
				    	   select * form 컬럼명 : 컬럼명에 대한 모든 테이블을 보여줌
				    	   
				    	   grant : 관리부여
				    	   
				    	    ex) grant 무엇 on 어떠한것 to 누구;
				    	    
				    	        grant connect to 누구;	: 접속 할 수 있는 권한을 부여
				    	        
				    	        grant resource to 누구;  : 만들고 지우고 등의 권한을 부여
				    	        
			 	 					-> grant connect, resource to 누구 : 한번에 두가지 권한을 부여
			 	 				
			 	 				drop user 누구; : 사용자 삭제
							
				    언어 : SQL(Structred Query Language)
				    
				    			- DDL 데이터 정의어 : 데이터 사용하기 위해 준비하는 정의어
									ㄱ. create
									ㄴ. alter(데이터를 사용할수있는 환경을 수정)
									ㄷ. drop
													
				    			- DML 데이터 조작어 : 데이터를 조작하는 조작어
				    				ㄱ. insert
				    				ㄴ. delete(데이터를 삭제)
				    				ㄷ. select(데이터를 수정)
				    			- QL 
									ㄱ. select(★★★★★)
									
								- DCL 데이터 제어어 : 데이터를 가지고 권한, 보안 등 제어어(관리자를 위한 언어)
									ㄱ. grant
									ㄴ. revoke
									
							select  
						      1. 데이터 검색
						      2. 기본 문법    
						        * SELECT 필드명,필드명,..... FROM [소유자.]테이블명
						           ex) select empno,ename,mgr, job FROM emp;
						           select * from 테이블명;
						       
						        * desc 필드명; : 테이블 구조 확인
						        
						        * 칼럼 길이 조정
						          col 칼럼명 for 9999; : 4자리숫자표현
						          col 칼럼명 for a8; : 8바이트 글자 
						          
						        * 필드 가공 처리
						         	1) 필드에 별명 부여 가능
										- 필드 [as] 별명
										- 필드 별명
										- 필드 as "별명" -> 필드에 띄어쓰기가 있는 경우
										- 필드 "별명"
										
						        * ed, run(/) : ed를 사용해서 작성하는 명령어는 C:\Users\jhta\afiedt.buf에 저장된다.
						                     : ed e:\test.sql	
						
				
				     select  
						 
						        * 필드 가공 처리
						         	1) 필드에 별명 부여 가능
										- 필드 [as] 별명
										- 필드 별명
										- 필드 as "별명" -> 필드에 띄어쓰기가 있는 경우
										- 필드 "별명"
										
									2) 중복 제거
										- distinct
										
							
								* 추가 문법
									1) 정렬 기능
										order by 필드명[asc(오름차순)-default | desc(내림차순)]	
										
									2) 조건문		
										where 조건식 
												(조건식 : 필드명 연산자 값, 실제저장된 데이터는 대소문자를 가린다)
												(연산자 : 
														  기본 연산자
															 -  >, <, >=, <=, =, <>, !=, ^=
														  
														  논리 연산자
														  	- and, or, not
														  
														  SQL 연산자
															  - between and, in(a,b,c), is null, 
															  - is not null
															  - like
															  		% : 0개 이상의 문자를 대체,갯수를 정확하게 알고 있지 않을때
															  		_ : 1개의 문자를 대체  ,갯수를 정확하게 알고있을때           )
					 
					 				    
								    
						* 함수
							1) Single-Row Function(단일행 함수) : 적용되는 대상이 하나의 레코드
									(1) 문자 함수	
											lower(), upper()
											substr('',몇번째, 몇개) : 문자의 일부분을 가져오는 함수
											length('', '원하는 문자', 문자의 시작위치,몇번째) 
											instr() 
											ltrim(), rtrim() : 공백제거
											tranlate('',  '바꾸고싶은 문자','원하는 문자')
												    ex) ('컬럼', '0123456789', '영일이삼사오육칠팔구') -> 하나하나의 값을 변환
											replace('',  '바꾸고싶은 문자','원하는 문자')			-> 단하나의 값을 변환
											char(), ascii()								
									
									(2) 숫자 함수
											round(숫자, 몇번째자리에서 반올림), trunc(버림), floor(내림), ceil()
											mod() : 나머지
											power() :거듭제곱
											sign() :양수 음수 구별
											
									(3) 날짜 함수
											sysdate(★★★)
											months_between()
											add_months
											next_day()
											last_day()
											reound(), trunc()
	
									(4) 변환 함수
											cast()
											to_char() 문자로변환
											to_number()
											
									(5) 기타 함수
											nvl('', 바꿔주고싶은값) : null값을 다른값으로 바꿔줌   
											decode(필드명, 'a', 'a입니다', 'b', 'b입니다', 'c', 'c입니다', '아무것도 아닙니다');
									(6) 정규식 함수
																   
										
							
							
							
							
							2) aggregate function (집합)
					 
							 ★실습★
									1. 직원들의 사번 이름 급여를 조회
										(단 급여를 100$를 추가 지급하여 검색하시오)
										 select empno, ename, sal+100 from eml;
							
							  		2. 직원들의 사번, 이름, 급여를 조회
							  			select empno as 사번, ename 이름, sal+100 as "100$추가된 급여" from emp;
							  			
							  		3. 이 회사에 어떤 업무들이 있는지 검색
							  		    select job from emp;  (중복허용)
							  		    select distinct job from emp;  (중복불가)
							  		    
							  		4. 이 회사에서 월급을 가장많이 받는사람
							  			사번 이름 부서 업무 급여를 검색
							  			select empno, ename, deptno, job,sal from emp order by sal desc
							  		    
							  		5. 부서별로 급여가 적은 순으로 직원의 이름 부서 급여
							  			select ename, deptno, sal from emp order by  sal;
							  			
									6. 업무가 'manager'인 직원의 사번 이름 급여, 업무를 조회
										select empno, ename, sal ,job from emp where job = 'MANAGER';
										
									7. 1982년 1월1일 이후에 입사한 직원의 이름, 부서, 입사일자를 조회하시오
										select ename, empno, hiredate from emp where hiredate >'1982.1.1';
										select ename, empno, hiredate from emp where hiredate >'1982-1-1';
										select ename, empno, hiredate from emp where hiredate >'1982-01-01';
										select ename, empno, hiredate from emp where hiredate >'1982,1,1';
										select ename, empno, hiredate from emp where hiredate >'1982 1 1';
										
											날짜는 자동적으로 형변형이된다.
											
									8. 부서가 20이고 업무가 analyst인 직원의 이름 부서 업무 조회
										select ename, deptno, job from emp where deptno=20 and job='ANALYST';
										
										
									9. 급여가 1500이상 2500이하를 받는 직원의 이름 부서 업무 급여를 조회
										select ename, deptno, job, sal from emp where sal>=1500 and sal <=2500;
										select ename, deptno, job, sal from emp where sal between 1500 and 2500;
										
									10. 업무가 clerk, salesman , analyst인 직원의 이름 부서 업무 조회
									    select ename, deptno, job from emp where job = 'CLERK' or job ='SALESMAN' or job = 'ANALYST';
									    select ename, deptno, job from emp where job in ('CLERK','SALESMAN', 'ANALYST');
									
									11. 이름이 s인 직원의 사번, 이름, 부서, 급여를 조회
										select empno, deptno, sal from emp where ename like 'S%'	
										
									12. 1981년도에 입사한 직원의 사번 이름 업무 입사일자
										select empno, ename, job, hiredate from emp where hiredate between '1981/01/01' and '1981/12/31';						 	
										select empno, ename, job, hiredate from emp where hiredate like '81%';		
										
									13.직원의 사번 이름 부서 업무 급여 보너스를 조회	
									   커미션 항목이 없는곳 조회
										select empno, ename, deptno, job, sal, comm from emp is null;	
										
									14. 커미션을 받을 수 있는 직원의 사번 이름 부서 업무 급여 보너스를 조회		
										select empno, ename, deptno, job, sal, comm from emp where comm is not null;	
									
									15. 커미션을 받지 못하는 직원의 사번, 이름, 부서, 업무, 급여 보너스를 조회
										select empno, ename, deptno, job, comm from emp where comm is null or comm ='0'; 	
	
									16. 업무가 manager, clerk, analyst가 아닌 직원의 사번 , 이름 업무 급여 부서를 조회
										select empno, ename, deptno, job from emp where job not in ('CLERK','SALESMAN', 'ANALYST');
										
									17. 업무가 president 또는 salesman 이고 급여가 1500이상인 직원의 사번 이름 업무 급여를 조회
										select empno, ename, job, sal from emp where (job ='SALESMAN' OR job = 'PRESIDENT' )and sal >=1500;
										
										
									18. 이름이 Scott인 직원의 이름 부서 급여를 조회 단, 대소문자구별없이검색할수잇도록 한다.
										select ename, deptno, sal from emp where upper(ename) = upper('scott');
										
									19. 다음의 주민번호에서 성별에 해당하는 값을 추출하시오.
										select substr('1111222-1234567', 9) "뒷자리" from dual;
										
									20. 문자열의 길이
										select length('안녕하세요....sql입니다.') from dual;
										select length(hiredate) from emp;
										
									21. 문자열의 위치
										select instr('MILLER', upper('l')) from dual;
										select instr('MILLER', 'L',1,2) from dual;
										select instr('MILLER', 'K') from dual;
										
									22. 문자열 제거
										select ltrim('MILLER', 'M') FROM DUAL;
										select ltrim('		MILLER') from dual;
										
									23. 문자열 재배치(치환)
										select translate('MALLER', 'L','*/') from dual;
										select replace(sal, '0123456789', '영일이삼사오육칠팔구') from emp;
										
										select translate('JACK and JUE','J','BL') from emp;
										select replace('JACK and JUE','J','BL') from emp;
														
									24. 아스키 코드
										select chr(65), chr(97) from dual;
										select ascii('A'), ascii('a') from dual;
										
									25. 소숫점 자리수
										select round(4567.678, -2), round(4567.458, 2) from dual;
										select trunc(4567.678) from dual;
										select floor(4567.678, 1) from dual;
										
									26. 나머지
										select mod(10,3) from dual;
										
									27. 거듭 제곱 
										select power(2,10) from dual;
										
									28. 부호 표현
										select sign(100), sign(-15), sign(0) from dual;
										
									29. 현재 날짜와 시간
										select sysdate from dual;
										select sysdate + 100 from dual;
										select months_between('2015/01/28', sysdate) from dual;
										
										select add_months(sysdate, 6) from dual;
										
										select next_day('2014/09/30', '화') from dual;
										select round('2014/10/01') from dual;
										
										select round(to_date('14/9/23'), 'MONTH') FROM DUAL;
										select round(to_date('14/9/23'), 'YEAR') FROM DUAL;
									
									
									30. 변환 함수
										select ename, sal, to_char(sal, '$999,999') from emp;
										select ename, sal, to_char(sal, 'l999,999') from emp;
										select to_char(sysdate, 'YYYY MM DD HH"시"MI"분"SS"초"') from dual;
										
									31. 기타 함수
										직원의 이름 급여 커미션 총급여를 조회
											select ename, sal, comm,sal+nvl(comm,0) from emp;
											select decode('파랑색','파란색','OK','파란색 아님') from dual;
											
	
			Aggregate Functions
				1) avg(), sum(), max(), min(),
				   count() : null 체크하지 않는다.
				   
				2) select 추가 문법
						group by 필드명[,...] having 조건절
						
				3) 정규 표현식 함수
						ㄱ. 지원 클래스
								ㄱ) java.util.regex
									Matcher
									Pattern
								
								ㄴ) java.lang.String
										matches(), replaceAll(), replaceFirst(), split()
										
						ㄴ. 기호
								ㄱ) . : 임의의 한 문자
									   ex) h.s -> has, hos, his, ...
									   	   ab. -> aba, abb, abc, ... 
									   	   
								ㄴ) * : 0개 이상의 문자(바로앞의 문자를 가르킨다.)
										ex) hello* -> hell, hello, helloooooooooooooooo, ...
											ab*c -> abc, ac, abbbbbbbbbbc, ...
											*b -> 안됨
											
								ㄷ) + : 1개 이상의 문자
									  ex) hello+ -> hell(x), hello, hello, hellooooooooo, ...
									  
								ㄹ) ? : 단 한개 혹은 없거나
									  ex) a?c -> c, ac
									  	  hello? -> hell, hello
									  	  try? -> tr, try
									  	  
								ㅁ) ^ : 문장의 처음(스타트선)
									   ex) ^hello ->  hello로 시작하는 모든 단어
									   
							  	ㅂ) $ : 문자의 끝
							  		   ex) world$ ->  world로 끝나는 모든 단어			
					
								ㅅ) [ ] : [  ]안의 문자 중 일치하는 것
									   ex) [abc] -> a, b, c, ab, ac, bc, abc, ...
									   ex) [김홍]길동 -> 김길동, 홍길동
									   ex) [a-z] -> a-z 소문자가 포함된 단어
									   ex) [0-9] -> 0-9 숫자가 포함된 단어
									   ex) ^[a-zA-Z0-9] -> 소문자 대문자 숫자로 시작되는 모든 문자열
									   ex) [^abc]de -> bde(x), dde, ede, fde, abc를 제외한 .de
									   ex) a[^0-9]c -> a와c사이엔 숫자가 안됨
								
								ㅇ) { } : 반복 갯수
										ex) hel{2}o -> hello
										ex) hel{3,}o -> hellllo,   helllo
										ex) hel{2,4}o -> hello,   helllo, he1111o
										
								ㅈ) ( ) : 묶음
									ex) (hello){3}  -> hellohellohello
									ex) (hello)+  -> hellohellohello
									
								ㅊ) | : or연산
									ex) man|woman -> man, woman, manwoman, superman, ..
									
								ㅋ) 문자 클래스  
									[a-zA-Z] [[:alpha:]] \p{Alpha}
									
									[0-9] [[:digit:]] \p{Digit}
									
									[a-zA-Z0-9] [[:alnum:]] \p{Alnum}
									
									공백    		[[:space:]] \p{Space}
									
								ㅍ) 특수문자의 일반 문자화
									a* -> a\*
								
								
								
				DML	(데이터 조작어)
					- insert
						ㄱ) insert into 테이블명[(필드명, ... )] valuse(값, ...)
						
					- update
						ㄱ) update 테이블명 set 필드명=값 where 조건절;
						
					- delete
						ㄱ) delete from 테이블명	where 조건절	
								
					*  flashback table 테이블명 to before drop;
					   show recyclebin; : 휴지통보여주기
					   purge recyclebin; : 휴지통비우기			
								
			실습
				1. 업무가 salesman인 직원들의 급여평균은 최고액, 최저액, 합계를 조회
					select avg(sal), max(sal), min(sal), sum(sal) from emp where job = 'SALESMAN';
				
				2. 직원이 총 몇명인가?
					select count(empno) from emp;
					select count(comm) from emp;
					select count(*) from emp;
					
					select trunc(sum(sal)/count(*)) from emp;
				
				3. 부서별로 급여 평균, 최고액, 최저액, 급여 합계를 조회
					select 	avg(deptno), max(deptno),min(deptno), sum(deptno) from emp where deptno=10;
					select 	avg(deptno), max(deptno),min(deptno), sum(deptno) from emp where deptno=20;
					select 	avg(deptno), max(deptno),min(deptno), sum(deptno) from emp where deptno=30;
			
					select deptno,avg(sal), max(sal),min(sal), sum(sal) from emp group by deptno;
					
				4. 부서별 직원 수를 조회
					select deptno, count(empno) from emp group by deptno;
					
				5. 부서별로 급여 평균, 최고 급여를 조회하는데, 단 급여 평균이 높은 순으로 조회하시오.
					select deptno,trunc(avg(sal)), max(sal), sum(sal) from emp group by deptno order by avg(sal) desc;
					
					
				6. 주의할 점
					select deptno, avg(sal), max(sal) from emp; -> 일반필드와 그룹필드는 같이 쓸수없다.
					select deptno, job, avg(sal), max(sal) from emp group by deptno, job order by job;
				
				7. 전체급여의 합계가 5000을초과하는 업무에 대해 급여 합계를 조회하시오
					select  job, sum(sal) from emp group by job  having sum(sal)>5000;
					
				8. 전체급여의 합계가 5000을초과하는 업무에 대해 급여 합계를 조회하시오 단,SALESMAN업무는 제외하시오
					select  job, sum(sal) from emp group by job having sum(sal)>5000 and job !='SALESMAN';
					select  job, sum(sal) from emp where job !='SALESMAN' group by job having sum(sal)>5000;
					
				9. 계정 작성 : dmltest/1111
					create user dmltest indetified by 1111;
					
				   권한 부여 : 
				    grant connect, resource to mdltest;
				    
				   테이블 작성(dmltest 접속)  :
				   	create table tbletest(id number, name varchar2(10), hiredate date)
				   	
				   insert 테스트
				    insert into tbletest(id, name, hiredate) values(1, '홍길동', sysdate);
				    insert into tbletest(id, name) values(2, '최초로');
				    insert into tbletest values(3, '최성령', '89/12/17');
				    
				   delect 테스트
				    delect from tbletest where id=1;
				    
			SubQuery		  
					1. 다음 Query문에 포함된 Query문
					
					2. 반드시 () 사용
					
					3. 연산자의 오른쪽에 사용해야 한다.
					
					4. order by 사용 불가
					
					5. 종류
						1) 서브 쿼리
							- 서브 쿼리가 혼자 실행이 된다.
						2) 상관 서브 쿼리
							- 서브 쿼리가 혼자 실행이 안된다.
							
							
					6. 유형
						1)단일행
							
						2)다중행
						
						3)다중열
						
					7. 연산자
						1)단일행
							=, >, < , >=, <= , <>
						
						2)다중행
							in : or 과 = 의 합
							any(or) : 최소값 기준의 or, 부등호와 같이 사용
							all(and): 최대값 기준의 and, 부등호와 같이 사용
							exists : 사용 시 상관 서브 쿼리 발생
							not
							
							
							
			JOIN
				1. 여러 개의 테이블을 병합하여 하나의 결과를 도출하기 위한 방법
						
				2. 종류
					(1) Caritesian Join(데카르트 곱)	: 실무에서 사용 안함
					
					(2) Equi Join (가장많이 사용)
							1) 공통 필드의 레코드를 가져오는 방법
							2) INNER JOIN(NatTural Join) : 중복 제거
							
								select tblA.id, tblA.value, tblB.id, tblB.value 
								from tblA inner join tblB
								on tblA.id = tblB.id;
								
								select a.id, a.value, b.id, b.value 
								from tblA a inner join tblB b 
								on a.id = b.id;
								 
							
							   
							
					(3) Non Equi Join
							1) 공통 필드가 없을 경우에 사용
					
					(4) Outer Join
							1) Extended Join(INNER JOIN + 공통되지 않은 레코드)
							2) 종류
								
									-Left Outer Join
									-Right Outer Join
									-Full Outer Join
				    
				    (5) Self Join
				    		1) 서로 같은 테이블을 조인					
							2) 
						
						
					* 실습 *
					
						단일행 유형
							1. scott의 급여보다 더 많이 받은 직원의 이름 , 업무 ,급여를 조회
							
								select ename, job, sal from emp 
									where sal > (select sal from emp where ename= 'SCOTT');
									
							2.  사번이 7521의 업무와 같고, 급여가 7934보다 많은 직원의 사번, 이름 업무, 급여를 조회
							
								select empno, ename, job, sal from emp where job = (select job from emp where empno='7521')
		                														and sal >( select sal from emp where empno = '7934');
		                														
		                    3.  업무 중 가장 적은 평균 급여를 받는 업무와 평균 급여를 조회
		                    	
		                    	select job, avg(sal) from emp group by job 
		             				 having avg(sal) = (select min(avg(sal)) from emp group by job);
	             					 
		             		4. 업무가 MANAGER인 직원의 사번, 이름, 업무, 급여 , 부서번호
		             			
		             			select empno, ename, JOB, sal, deptno  from emp where job ='MANAGER';
								select empno, ename, job, sal, deptno from( select * from emp where job = 'MANAGER');
	              
						다중행 유형
							5. 업무별로 최소 급여를 받는 직원의 사번, 이름, 업무, 급여, 부서번호
							
								select empno, ename, JOB, sal, deptno  from emp  where sal in( select min(sal) from emp group by JOB);
							
							6. 업무별로 최소급여보다 많은 급여를 받는 직원의 사번, 이름, 업무, 급여, 부서번호
							
								select empno, ename, JOB, sal, deptno  from emp  where sal > any( select min(sal) from emp group by JOB);
								
							7. 업무별로 최대급여 이상 받는 급여를 받는 직원의 사번, 이름, 업무, 급여, 부서번호
								
								select empno, ename, JOB, sal, deptno  from emp  where sal >= all( select max(sal) from emp group by JOB);
								
							8. 상관 서브 퀴리
								
								적어도 한번의 직원으로부터 보고를 받을 수있는 직원의 이름, 업무, 입사일자, 급여를 조회
								
								select empno, ename, job, hiredate, sal from emp e where exists(select * from emp where e.empno= mgr);
								
							9. 다중열
								1) 사번이 7934인 직원의 급여를 1500, 커미션을 300으로 수정
									update emp set sal=1500 , comm=300 where empno=7934;
								2) 10번 부서의 직원들에 대해 사번,이름 급여,커미션 조회
									select empno,ename,sal,comm from emp where deptno = 30;
								3) 급여와 커미션이 30번 부서에 있는 직원의 급여와 커미션이 같은 직원에 대해 사번,이름,부서번호, 급여,커미션을 조회
									select empno, ename, deptno, sal, comm from emp where (sal, comm) in(select sal, comm from emp where deptno = 30);
									
									
						조인실습
							10.  
								1) jointest 계정 생성후 권한 주기
								
									create user jointest identified by 1111;
									grant connect, resource to jointest;
									
								2) 테이블 생성 
									 create table tblA( id number, value number);
									 create table tblB( id number, value number);
	
									 
								3) 데이터 입력
									insert into tblA Values(1,10);
									insert into tblA Values(2,20);
									insert into tblA Values(3,30);
									insert into tblA Values(5,50);
									insert into tblA Values(7,70);
									
									insert into tblB Values(1,10);
									insert into tblB Values(2,20);
									insert into tblB Values(4,40);
									insert into tblB Values(5,50);
									insert into tblB Values(8,80);
									
								4) INNER JOIN
								
								
								   4-1)직원의 사번 이름 업무 부서번호 부서명조회
								 	 	select empno, ename, job, a.deptno, b.dname from emp a inner join dept b on a.deptno = b.deptno;
								   
								   4-2)salesman에 대해서 사번 이름 업무 부서번호 부서명을조회
								   		select empno, ename, job, a.deptno, b.dname from emp a inner join dept b on a.deptno = b.deptno where job='SALESMAN';
								   	
								   4-3)newyork에서 근무하는 직원의 사번, 이름, 업무, 부서명을 조회
										select empno, ename, job, a.deptno, dname, loc from emp a inner oin dept b on a.deptno = b.deptno and loc='NEW YORK';
										
								5) OUTTER JOIN
									
								5-1)	select tblA.id, tblA.value, tblB.id, tblB.value 
										from tblA left outer join tblB
										on tblA.id=tblB.id;
										
								5-2)	select tblA.id, tblA.value, tblB.id, tblB.value 
										from tblA right outer join tblB
										on tblA.id=tblB.id;
										
								5-3)	select tblA.id, tblA.value, tblB.id, tblB.value 
										from tblA full outer join tblB
										on tblA.id=tblB.id;
										
								5-4)	select tblA.id, tblA.value, tblB.id, tblB.value 
										from tblA , tblB
										where tblA.id=tblB.id(+);
								
								5-5)	select tblA.id, tblA.value, tblB.id, tblB.value 
										from tblA , tblB
										where tblA.id(+) = tblB.id;
										
								5-6) 	이름 급여 부서명 근무지를 조회하시오 단 , 부서명과 근무지는 모두 출력할 수있도록 하시오
										select ename, sal, job, loc
										from emp a right outer join dept b
										on a.deptno = b.deptno;
		
				JOIN
		
						1)  Non Equi Join (자주 사용되지않지만, DB설계에 따라 사용됨)
								ex)	select ename, job, sal gread , losal from emp inner join salgrade on sal>= losal and sal<=hisal;
								
								
						2) Self Join
								- 서로 같은 테이블을 조인
				
				
				
				SET 연산자 ( 사용 빈도가 낮음 )
						
						1) union( 합집합 )
							 select deptno from dept union select deptno from emp; -> 중복을 제거
							 
							 
						2) union all( 합집합 )
							 select deptno from dept union all select deptno from emp; -> 중복을 허용
						
						
						3) intersect( 교집합 )
						 	select deptno from dept intersect select deptno from emp;
						
						
						4) minus( 차집합 )
							select deptno from dept minus select deptno from emp;
						
					
				
				Transaction
					
						all or nothing!
				
							1. 로그파일에 작업 기록을 해놓음으로써 작업이 제대로 성공하지 못했을 경우 다시 원래대로 돌아갈 수 있도록 해준다.
							2. DML 작업만 기록된다.
								ㄱ. insert
				    			ㄴ. delete
				    			ㄷ. select
				    			
				    		3. ROLLBACK, COMMIT
				    			
				    			- begin transaction : 시작 Transaction 지점 
				    			- end transaction : 끝 Transaction 지점 
				    			
				    		4. 동기화;
				    			
				    			
				   Data Integrity
				    			
						1. 무엇을 지킬 것인가? (what)
						
								1) 실체(Entity) 무결성  ( 테이블 )
										- 중복된 데이터 방지( 최선의 방지 )
										- Primary Key, Unique ( 제약 )
										
										
								2) 영역(Domain) 무결성
										- 범위
										- Check ( 제약 )
										
										
								3) 참조(Reference) 무결성 (최소한 두개테이블에서 발생하는 사건)
										- 참조
										- Foreign Key
										
										- 참조하는 테이블 ( 자식테이블 )
										- 참조당하는 테이블 ( 부모테이블 ) 
										- 참조키 (필드) - 나만 가지고있는 곳
										
										
						2. 컬럼의 속성
							- NN(Not Null) 속성		
									Primary Key, not null, 
							- ND(no duplicate) 속성 : 똑같은 값이 들어오는걸 막아준다.
									Primary Key,Unique
							- NC(no change) 속성		
									Foreign Key
									
									
						3. Primary Key (기본키)
							1) 하나의 테이블 당 단, 하나만 설정
							2) 여러개의 컬럼을 묶어서 설정 가능
							3) 자동정렬(index)
							4) UNIQUE : 중복 방지 하지만 null은 막지못한다.
										하나의 테이블에 여러개가 가능
										
					
						4.1 테이블 생성시  기본키 추가
						
							create table tblexam(id number constraint pk_id Primary Key, name varchar2(10) not null);
									
									
						4.2 기본키 추가 문법
							alter table tblexam add constraint pk_id primary key(원하는 필드);
						
						
						4.3 여러칼럼을 한번에 묶어서 기본키 추가하는 문법
							create table tblexam(id number , name varchar2(10) not null, constraint pk_id Primary Key(id, name));
						
						
						5. 기본키 삭제
							
							alter table tblexam drop constraint pk_id;
							
							select constraint_name, table_name, status from user_constraints;
					
					
						6. 필드 추가
						
							alter table tblexam add age number not null;
						
						7. 필드 수정
						
							alter table tblexam modify age number(id) not null;
					
					
						8. check (영역 설정)
						
							create table tblexam(id number, name varchar2(10), city varchar2(10) check(cith='서울' or city='경기'));
							
							insert into tblexam values(1, '홍길동', '서울'); 가능
							insert into tblexam values(1, '홍길동', '전주'); 불가
	
	
							create table tblexam(id number, name varchar2(10), city varchar2(10), constraint ck_city check (city in('서울' ,'경기')));				
					
							이 상태에서 현재 테이블에 age필드를 추가하여 나이를 0에서 100까지만 입력받을 수 잇게 해라.
	
					
	
						
	
			  Data Integrity
				    			
						1. 무엇을 지킬 것인가? (what)
						
								1) 실체(Entity) 무결성  ( 테이블 )
										- 중복된 데이터 방지( 최선의 방지 )
										- Primary Key, Unique ( 제약 )
										
										
								2) 영역(Domain) 무결성
										- 범위
										- Check ( 제약 )
										
										
								3) 참조(Reference) 무결성 (최소한 두개테이블에서 발생하는 사건)
										- 참조
										- Foreign Key
										
										- 참조하는 테이블 ( 자식테이블 )
										- 참조당하는 테이블 ( 부모테이블 ) 
										- 참조키 (필드) - 나만 가지고있는 곳
										
										
						2. 컬럼의 속성
							- NN(Not Null) 속성		
									 Primary Key, not null 
							- ND(no duplicate) 속성 : 똑같은 값이 들어오는걸 막아준다.
									 Primary Key, Unique
							- NC(no change) 속성		
									 Foreign Key
									
									
						3. Primary Key (기본키)
							1) 하나의 테이블 당 단, 하나만 설정
							2) 여러개의 컬럼을 묶어서 설정 가능
							3) 자동정렬(index)
							4) UNIQUE : 중복 방지 하지만 null은 막지못한다.
										하나의 테이블에 여러개가 가능
										
						4. check (영역 설정)
						
						
						5. Default 
							(1) Null값 방지 
								ex)create table tblexam(id number Default 0, name varchar2(10) Default '초로씨', city varchar2(10) );		
								   inserte into tblexam(id,city) values(1,'태평리');	
								   inserte into tblexam(city) values('전주');	
									 
								   city 에서 default로 서울을 지정하도록 해보자
									 	- alter table tblexam modify city varchar2(10) Default '서울';
									 	
						6. Sequence
							(1) Null값과 중복을 방지
							(2) 일련번호 지정
							(3) 정수형 필드에만 사용 가능
							
								ex) create Sequence sq_idx; 
									create table tblexam(id number, name varchar2(10) , city varchar2(10) );
									insert into tblexam values(sq_idx.nextVal, '홍길동','서울');		
							
							
						7. 참조 무결성
							부서 테이블
								create table tbldept(deptno char(3),        <- 고정 길이 문자
													 dname varchar2(10));	<- 가변 길이 문자(융통성)						
									 
								insert into tbldept values('100' , '영업부');
								insert into tbldept values('101' , '개발부');
								insert into tbldept values('102' , '인사부');
									 		
								alter table tbldept add constraint pk_deptno primary key(deptno); 	
							직원 테이블		 		
								create table tblemp(id number, name varchar2(10) , city varchar2(10), hire date, deptno char(3) );
								
								insert into tblemp values(sq_idx.nextVal, '홍길동', sysdate, '100');					
								insert into tblemp values(sq_idx.nextVal, '홍길동', sysdate, '105');		
							
							**참조키 추가
								alter table tblemp add constraint fk_dept_emp_deptno foreign key(deptno) references tbldept(deptno);
								
								
								update tbldept set deptno='111' where deptno='102'; 
								update tbldept set deptno='200' where deptno='101'; 
								
			
			table name post 
			
				create table post(post1 char(3), 
								  post2 char(3), 
								  addr varchar2(60) not null, 
								  constraint pk_post Primary Key(post1, post2));
	
			table name member 
				
				create table member(id number(4) constraint pk_id_number Primary Key,
									name varchar(10) not null,
									sex char(1) check(sex in('1','2')),
									jumin1 char(6),
									jumin2 char(7),
									tel varchar(15),
									post1 char(3), 
								    post2 char(3),
								    addr varchar(60),
								    constraint uk unique (JUMIN1, JUMIN2),   
								    constraint pk_jumin foreign Key(post1,post2) references post(post1,post2));
	
		 
		 
		 VIEW	
		 
		 	1. 실제 테이블을 여러 관점에서 투영한 가장 테이블
		 	2. 목적 
		 		(1) 사용자의 편의
		 		(2) 보안성
		 			
		 	3. 문법
		 		
		 		create view 뷰이름[(칼럼명, ...)]
		 		as
		 		select 필드명, ... from 테이블명
		 		
		 	4. 수정불가
		 		create or replace view vw_test1 as select empno, ename, deptno, job from emp where deptno = 20;
		 		
		 	5. VIEW의 주의할점(뷰를 통한 테이블의 수정)
		 	
		 	(1)  view를 통해 입력되지 않는 컬럼에 대한 설정
		 		create or replace view vw_test1 as select ename, deptno, job from emp where deptno = 30;
				
				insert into vw_test1 values('test', 30, 'salsman');
		 			- > 하나의 필드가 널값을 받기때문에 에러가 발생
		 			- > 뷰 생성지 빠진 필드를 넣어줘야함
		 		
		 		 
		 	(2) view를 통해 계산된 컬럼이나 파생된 컬럼의 수정
		 		create or replace view vw_test1 as select ename, deptno, sal + nvl(comm, null) as total from emp where deptno = 30;
		 		
		 		update vw_test1 set total = 100	where ename='scott';
		 				
		 				
		 	(3) view를 통해 여러 테이블을 수정 
		 		create or replace view vw_test1 as select ename, sal, job, dname, loc from emp inner join dept on emp.deptno = dept.deptno;
		 			
				update vw_test1 set job='aaa' , loc='bbb' where vw_test1;
					-> 두개의 테이블 수정 불가
			
			(4) 범위가 벗어난 수정
		 		create or replace view vw_test1 as select empno, ename, deptno,sal job from emp where deptno=30;
		 		
				update vw_test1 set deptno='20' where empno=7499;
		 			->결과에서 빠져나감
			
				-> with check option 		
		 	
		 		create or replace view vw_test1 as select empno, ename, deptno,sal job from emp where deptno=30 with check option;
	
	
	
		Stored Procedure
			
			1. 정의
					자주 사용하는 쿼리문을 미리 컴파일하여 필요할 때 호출
							
			2. 문법
			
					create or replace procedure 이름[(파라미터, ...)] is begin 로직 end;
					
					create or replace procedure 이름[(파라미터, ...)] is begin 로직 if 처리문 then else 처리문 end if; end;
					
					
			3. pl/sql에서의 block
			
					declare
							- 선언문
							
					begin
							- 실행 및 처리부
							
					exception
							- 예외처리
									
					end;
							
			*   set serveroutput on 
	
	
	
	
		 	* 실습
		 		grant create view to scott;
		 		
		 		create view vw_test1 as select empno, ename, deptno ,job from emp;
		 		
		 		select view_name , text from user_view;
		 		
		 		create or replace view vw_test1 as select empno, ename, deptno, job from emp where deptno =20;
		 		
		 		1. 사번이 7788인 사원의 급여를 3500로 수정하는 프로시저를 작성하시오
		 			select empno, ename, sal from emp where empno=7788;
		 			
		 			create or replace procedure sp_emp_update is begin update emp set sal=3500 where empno=7788; end;
		 			
		 			execute(exec) sp_emp_update;
				
				2. 매개변수를 갖는 프로시져
				
		 			create or replace procedure sp_emp_update(p_sal in number,p_empno in number) 
		 						is begin update emp set sal=p_sal where empno=p_empno; end;
		 						
		 			exec sp_emp_update(3500,7788);
		 			
					-- 위의 프로시저를 좀 더 개선해 보자(환경변수 - %type)
					
						create or replace procedure sp_emp_update(p_sal in emp.sal%type, p_empno in emp.empno%type) 
		 						is begin update emp set sal=p_sal where empno=p_empno; end;
		 						
		 				exec sp_emp_update(3500,7788);
		 				
		 			--
		 			
		 				create or replace procedure sp_emp_update(p_sal in emp.sal%type, p_empno in emp.empno%type) 
		 						
		 						is begin update emp 
		 						set sal=p_sal 
		 						where empno=p_empno; 
		 						
		 						if sql%notfound then dbms_output.put_line(to_char(p_empno) || '는 없는 사원번호입니다.'); 
		 						else
		 						   dbms_output.put_line(to_char(sql%rowcount) || '명의 자료를 수정하였습니다.'); 
		 						   end if; 
		 						   end;
		 						   
		 						  set serveroutput on 
	
		 	
		 	Stored Procedure
		 	
		 	 	2. 특정한 수에 7%의 세금을 계산하여 그 결과를 돌려받을 수 있는 프로시저를 만들어라
		 	 	
			 	 	   create or replace procedure 이름[(파라미터, ...)] is begin 로직 end;
			 	 	   
			 	 	   	- in  : 입력을 받는 매개변수
			 	 	   	- out : 출력을 하는 매개변수
			 	 	   	- :=  : 대입연산자
			 	 	   	- :   :  선언된 변수를 사용하겠다는 표시
			 	 	   									
				 	   create or replace procedure usp_tax(p_num in number, p_result out number ) is begin p_result := p_num * 0.07; end;
				 	  
				 	   set serverout on
				 	   
				 	   var g_result number;
				 	   
				 	   exec usp_tax(3500, :g_result);
			 	  
			 	  
			 	  3. 사원 등록 프로시저를 만들자.
			 	  	사원의 이름, 업무, 직속상사, 급여를 입력받아 등록한다.
			 	  	단, 부서번호는 1)직속상사의 부서번호와 같고
			 	  	2)커미션은 salesman일 경우에는 0, 그외에는 null을 입력
			 	  	
			 	  	1) select deptno into v_deptno from emp where empno=p_mgr;
			 	  	2) if p_job ='SALESMAN' then v_comm := 0; else v_comm := null; end if;
			 	  	3) create Sequence sq_idx; 시퀀스 생성	    
			 	  			 create Sequence sq_idx;  
			 	  	
			 	  			 create or replace procedure sp_register(p_ename in emp.ename%type, p_job in emp.job%type, p_mgr in emp.mgr%type, p_sal in emp.sal%type) 
			 	  			 is
			 	  			 		v_deptno	emp.deptno%type;
			 	  			 		v_comm		emp.comm%type;
			 	  			 		
			 	  			 begin
			 	  			 		select deptno into v_deptno from emp where empno=p_mgr;
			 	  			 		
			 	  			 		if p_job ='SALESMAN' then 
			 	  			 					v_comm := 0;
			 	  			 		else 
												v_comm := null;
									end if;
			 	  			 		insert into emp(empno, ename, job, mgr, sal, deptno, comm, hiredate) values(sq_idx.nextval, p_ename, p_job, p_mgr, p_sal, v_deptno, v_comm, sysdate);
			 	  			 end;
			 	  			 
			 	  	4. 위에 예제를 예외처리 추가하여 개선해 보자.
			 	  	
			 	  			 create or replace procedure sp_register(p_ename in emp.ename%type, p_job in emp.job%type, p_mgr in emp.mgr%type, p_sal in emp.sal%type) 
			 	  			 is
			 	  			 		v_deptno	emp.deptno%type;
			 	  			 		v_comm		emp.comm%type;
			 	  			 		v_job_err   exception;
			 	  			 		
			 	  			 begin
			 	  			 		select deptno into v_deptno from emp where empno=p_mgr;
			 	  			 		
			 	  			 		if p_job not in('CLERK', 'SALESMAN', 'PRESIDENT', 'MANAGER', 'ANALYST')then raise v_job_err;
			 	  			 		
			 	  			 		elsif p_job = 'SALESMAN' then 
			 	  			 					v_comm := 0;
			 	  			 		else
												v_comm := null;
									end if;
									
			 	  			 		insert into emp(empno, ename, job, mgr, sal, deptno, comm, hiredate) values(sq_idx.nextval, p_ename, p_job, p_mgr, p_sal, v_deptno, v_comm, sysdate);
			 	  			 		
			 	  			 exception
			 	  			 		when v_job_err then dbms_output.put_line('업무를 잘못 입력햇네');
			 	  			 		when no_data_found then dbms_output.put_line('입력한 데이터가 없네');
			 	  			 		when others then dbms_output.put_line('기타 에러');
			 	  			 end;		 
			 	  			 
			 	  	5. 이름을 입력받아 그 직원의 부서명과 급여를검색하는 프로시저
			 	  			 			 create or replace procedure sp_search(p_ename in emp.ename%type, p_dname out dept.dname %type, p_sal out emp.sal%type)
			 	  			 			 is
			 	  			 			 	v_deptno			emp.deptno%type;
			 	  			 			 begin
			 	  			 				 select  sal, deptno into p_sal, v_deptno from emp where ename=(p_ename);
			 	  			 				 
			 	  			 				 select dname into p_dname from dept where deptno=v_deptno;
			 	  			 			 end;
			 	  			 			 
			 	  			 			 var g_dname varchar2(14)
			 	  			 			 var g_sal number
			 	  			 			 
			 	   6. 전화번호를 입력하고 다시 전화번호를 리턴받는 프로시저
								create or replace procedure sp_tel(p_tel in out varchar2)				 	   
				 	  			is
				 	  			begin
				 	  					p_tel := substr(p_tel, 1, 3) || '-' || substr(P_tel, 4);
				 	  			end;
				 	  			 	
				 	  			var g_tel := 1234567
				 	  			
				 	  			begin
				 	  			:g_tel := 1234567;
				 	  			end;
				 	  			
				 	  			exec sp_tel(:g_tel)
				 	  			
				 	  			print :g_tel
				 	  			
				 	  			
				 	  			
				trigger(자동실행)
						0. 기본적으로 테이블에 걸어줌
						 
						1. 이벤트에 의해 자동으로 호출되어 실행되는 프로시저
								- dml(insert, update, delete)
						2. 문법
							create or replace trigger 트리거명
										{before | after} 트리거 이벤트 on 테이블명
										[반복문]
							begin
							end;
							
						3. DD : user_triggers
						
						4. 트리거는 기본적으로 2개의 임시테이블을 가지고 있다.
										old(:old) 삭제 , new(:new) 추가
										업데이트는 둘다 사용
										
						
						실습
							1. emp 테이블에서 급여를 수정할때 현재의 값보다 적게 수정할 수 없고 현재의 값보다 10%이상 높게 수정할 수 없도록 제한하는 트리거					
						
								create or replace trigger tr_emp_update before update on emp 
								begin 
									raise_applicateion_error(-20000, '수정된 값이 잘못됨'); 
								end;
								
								
		
			제1정규화 : 하나의 속성은 오직 하나의 원자값을 취해야 한다.
					   반복되는 속성이나 그룹의 속성을 제거하고, 새로운 엔티티를 추가한 후에 기존의 엔티티와 일대다의 관계를 형성한다. 
					   
			제2정규화 : 기본키의 일부분에 의존적이어서는 안된다.
			
			제3정규화 : 키가 아닌 컬럼은 다른 키가 아닌 컬럼에 의존적이어서는 안된다.
			
			
			비식별 1:n
			식별 1:1
			
			
			UML
				1. 일반화(generalization)
					1) is a 관계 - 동격, 클래스 사이의 상속 관계
					2) 인터페이스 구현
				2. 연관(association) - has a 관계
					1) 의존(dependency)  : 가져와 사용
					2) 집합(aggregation) 
					3) 합성(composition) 
			
				0. 1) 실선의 검은색 머리, 세로 : 상속
				0. 2) 실선에 흰색 머리, 세로 : 추상
				0. 3) 점선에 흰색 머리, 세로 : 인터페이스
				0. 4) 점선에 흰색 마름모, 가로 : 합성 
				0. 5) 점선에 검은색 마름모, 가로 : 집합
	/		
			create table tblinput(
	   num   number,
	   name   varchar2(30) not null,
	   cnt   number not null,
	   constraint pk_num primary key(num)
	);
	
	create table tblstock(
	   num   number,
	   name   varchar2(30) not null,
	   cnt   number not null,
	   constraint pk_num1 primary key(num)
	);
	
	create table tbloutput(
	   num   number,
	   name   varchar2(30) not null,
	   cnt   number not null,
	   constraint pk_num2 primary key(num)
	);
	
	create or replace trigger sdaf after insert on tblinput for each row
	
	
	CREATE OR REPLACE TRIGGER tr_input AFTER INSERT ON tblInput
	FOR EACH ROW
	BEGIN   
	   update tblstock set cnt = cnt+:new.cnt
	   where name = :new.name;
	   if sql%notfound then insert into tblstock values( :new.num , :new.name , :new.cnt );
	   end if;
	END;
	/
	
	CREATE OR REPLACE TRIGGER tr_output AFTER INSERT ON tbloutput
	FOR EACH ROW
	BEGIN   
	   
	   update tblstock set cnt = cnt-:new.cnt
	   where name = :new.name and cnt > :new.cnt;
	   if sql%notfound then raise_application_error(-20506, '수량을 초과 했습니다.' );
	   end if;
	END;
	
	
				* odbc 
					->  어떤 응용프로그램을 사용하는지에 관계없이, 데이터베이스를 자유롭게 사용하기 위하여 만든 응용프로그램의 표준방법 
				* jdbc
					-> 자바 프로그램 안에서 SQL을 실행하기 위해 데이터베이스를 연결해주는 응용프로그램 인터페이스를 말한다
	
				* file.sql : 이클립스에서 db사용
				
				** JDBC
				
					1) 해당 dbms 드라이버를 구한다.
					2) 자바와 db의 연결 테스트
							(1) 해당dbms 드라이버를 로딩한다.
							(2) db와의 작업을 위한 3총사 객체
									- Connection conn = null; 				: db연결
									- Statement stmt = null;				: 명령어 전달 및 실행
									- ResultSet rs = null;					: 결과를 프로그램으로 가져올때
									
					3) ResultSet
						(1) DB로부터 가져온 결과를 임시로 저장하는 객체 (자바 측 메모리)
						(2) 하나의 테이블을 저장할수 있는 구조
						(3) 연결 지향적
						(4) forward only은 옛말이다.
								next();
						(5) 반드시 처음에는 next()로 호출해야 한다. 		
						
						
			** PreparedStatement
				- select like 연산자는 사용불가
				- prepareStatement() 메소드를 사용하여 생성
				
				
			* Web Application
				- 클라이언트용 : IE  
				- 서버용
						
			
					호환성 -> 웹표준화
					
					서버 P/G - Client Side	: html, javascript, css
					   		- Server Side  : java 
					
				
	
	

		**** MYSQL ****
				
			접속 : mysql -u root -p
				  
			
			DB생성 : create database 디비이름;
			
			이동 : use 디비이름;
			
			보기 : show tables;
			
			TABLE생성 : 
			
					ex)
						create table tblsawon(
							no		int not null auto_increment,
							id  	varchar(20),
							name 	varchar(20),
							pass	varchar(10),
							age		int(2),
							addr	varchar(50),
							ext		char(4),
							dept	varchar(10),
							constraint pk_no primary key(no)
							
						);
						
	create table tblmap(no int not null auto_increment, title varchar(30), latingx varchar(20), latingy varchar(20), date date, constraint pk_no primary key(no) );
		    데이터 입력 : 
		    
							insert into tblmap(latingx,latingy,date) values('41.123123','21.1231',sysdate);
		    		ex) 
		    			
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values('hong', '홍길동', '1111', 20, '서울', '3431','영업');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values('hong', '홍길동', '1111', 20, '서울', '3431','영업');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values('hong', '홍길동', '1111', 20, '서울', '3431','영업');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values( 'lim', '임꺽정', '2222', 29, '광주', '3432','영업');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values( 'lee', '이순신', '3333', 39, '부산', '3433','영업');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values( 'shin', '신돌석', '4444', 36, '서울', '3434','기술');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values('jang', '장보고', '5555', 20, '서울', '3435','기술');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values( 'ahn', '안창호', '6666', 34, '경기', '3436','기획');
							insert into TBLSAWON(id,name,pass,age,addr,ext,dept) values('yun', '윤봉길', '7777', 25, '경기', '3437','기획');



		
		**** 기타 ****
		
				1. DBCP(Data Base Connection Pool)	
					- 중복코딩 , 성능저하(잦은 연결과 해체로 인한) 등 불안전함을 해결해줌
					
					- Connection Pool이란, DB에 접근할 때 마다 연결을 했다. 끊었다. 하는게 아니라, 
					  프로그램에서 미리 몇 개의 연결을 해 놓은 후 필요할 때 마다 Pool에서 연결을 빌려와서 다시 반환한다. 
					
					- DB Connection
					  연결 - DB - 종료
						
					- DB Connection Pool
					  연결요청 - Connection Pool - 반환
					
					
					*해결방법
					 	1. 직접 작성
					 	2. 라이브러리 (common.dbcp, ...)   -> JNDI
					 	3. Was에서 제공					  -> JNDI
					
					* JNDI(Java Naming and Directory Interface)
						:  디렉터리 서비스에서 제공하는 데이터 및 객체를 
						   발견(discover)하고 참고(lookup)하기 위한 자바 API
						   
					* DBCP 중요 메서드
					  
						  DBConnectionMgr.java
								  getInstance  : cp객체의 위치를 알려, 사용할수 있도록 함
								  			   : 싱글 톤
								  			   
								  getConnection : db연결 객체를 cp로 빌려옴 
								  
								  freeConnection : 빌려왔던 객체를 반납
					
					
					
					
					* SQL Loader (= 컨트롤파일 )
						
						[[ 오라클 ]]
						- ex)  LOAD DATA
								INFILE zipcode.csv
								INTO TABLE tblzip INSERT
								FIELDS TERMINATED BY ','
								(zipcode, sido, gugun, dong, bunji)
								
						- 명령어  sqlldr control=zip.ctl userid=아이디/비번
						
						[[ MYSQL ]]
						
						- ex)
						
							create table tblzip(
										                zipcode varchar(10),
										                SIDO    VARCHAR(5),
										                GUGUN    VARCHAR(20),
										                DONG    VARCHAR(60),
										                BUNJI   varchar(20)
										              );
	
	
							LOAD DATA
							LOCAL INFILE 'C:\\kong\\zip\\zipcode.csv'
							INTO TABLE tblzip(zipcode, sido, gugun, dong, bunji);
